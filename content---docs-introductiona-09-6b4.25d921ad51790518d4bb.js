(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{39:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return l}));n(0);var r=n(60);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i={id:"introduction",title:"Introduction",sidebar_label:"Introduction"},s=[],c={rightToc:s},u="wrapper";function l(e){var t=e.components,n=a(e,["components"]);return Object(r.b)(u,o({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"React Context and useContext is often used to avoid prop drilling,\nhowever it's known that there's a performance issue.\nWhen a context value is changed, all components that useContext\nwill re-render.\nReact idiomatic usage of the Context API is\nto separate concerns into pieces and use multiple contexts.\nIf each context value is small enough, there shouldn't be\nany performance issue."),Object(r.b)("p",null,"What if one wants to put a bigger state object into a context\nfor various reasons?\nReact Redux is one solution in this field. Redux is designed to\nhandle one big global state, and React Redux optimizes that use case."),Object(r.b)("p",null,"This library tosses a new option. It's based on Context and\ntypically with useReducer, and provides APIs to solve\nthe performance issue.\nMost notably, it comes with ",Object(r.b)("inlineCode",{parentName:"p"},"useTrackedState"),", which allows\noptimization without hassle. Technically, it uses Proxy underneath,\nand it tracks state usage in render so that if only used part of the state\nis changed, it will re-render."))}l.isMDXComponent=!0},60:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return p}));var r=n(0),o=n.n(r),a=o.a.createContext({}),i=function(e){var t=o.a.useContext(a),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},s=function(e){var t=i(e.components);return o.a.createElement(a.Provider,{value:t},e.children)};var c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},l=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,c=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===t.indexOf(r)&&(n[r]=e[r]);return n}(e,["components","mdxType","originalType","parentName"]),l=i(n),p=r,d=l[s+"."+p]||l[p]||u[p]||a;return n?o.a.createElement(d,Object.assign({},{ref:t},c,{components:n})):o.a.createElement(d,Object.assign({},{ref:t},c))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=l;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}l.displayName="MDXCreateElement"}}]);